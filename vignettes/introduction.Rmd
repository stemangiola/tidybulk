---
title: "tidybulk: An R tidy framework for modular transcriptomic data analysis"
author: "Stefano Mangiola"
date: "`r Sys.Date()`"
package: tidybulk
output:
  BiocStyle::html_document:
    toc_float: true
bibliography: references.bib
link-citations: true
abstract: >
  Tidybulk is a comprehensive R package for modular transcriptomic data analysis that brings transcriptomics 
  to the tidyverse. It provides a unified interface for data transformation, normalization, filtering, 
  dimensionality reduction, clustering, differential analysis, cellularity analysis, and gene enrichment 
  with seamless integration of SummarizedExperiment objects and tidyverse principles.
keywords: "transcriptomics, RNA-seq, differential expression, data analysis, tidyverse, SummarizedExperiment, 
  bioinformatics, genomics, gene expression, clustering, dimensionality reduction, cellularity analysis, 
  gene enrichment, R package"
vignette: >
  %\VignetteEngine{knitr::knitr}
  %\VignetteIndexEntry{Overview of the tidybulk package}
  %\usepackage[UTF-8]{inputenc}
knit: >
    (function(x, ...){
        proj_root <- rprojroot::find_package_root_file() |> normalizePath()
        
        # Set knitr options for both renders
        knitr::opts_knit$set(root.dir = proj_root)
        
        rmarkdown::render(
            x,
            output_file = "README.md",
            output_format = "github_document",
            output_dir = proj_root,
            knit_root_dir = proj_root,
            params = list(
                demo_metadata = FALSE
            )
        )
    })
---

<!-- badges: start -->
[![Lifecycle:maturing](https://img.shields.io/badge/lifecycle-maturing-blue.svg)](https://www.tidyverse.org/lifecycle/#maturing) 
[![R build status](https://github.com/stemangiola/tidybulk/workflows/R-CMD-check/badge.svg)](https://github.com/stemangiola/tidybulk/actions/)
[![Bioconductor status](https://bioconductor.org/shields/build/release/bioc/tidybulk.svg)](https://bioconductor.org/checkResults/release/bioc-LATEST/tidybulk/)
<!-- badges: end -->

# <img src="`r ifelse(knitr::pandoc_to() %in% c('html', 'html4'), '../inst/logo.svg', 'inst/logo.svg')`" height="139px" width="120px"/>

**tidybulk** is a powerful R package designed for modular transcriptomic data analysis that brings transcriptomics to the tidyverse.

## Why tidybulk?

Tidybulk provides a unified interface for comprehensive transcriptomic data analysis with seamless integration of SummarizedExperiment objects and tidyverse principles. It streamlines the entire workflow from raw data to biological insights.

# <img src="`r ifelse(knitr::pandoc_to() %in% c('html', 'html4'), '../inst/new_SE_usage-01.png', 'inst/new_SE_usage-01.png')`" width="100%"/>

## Functions/utilities available

### Abundance Normalization Functions
Function | Description
------------ | -------------
`scale_abundance()` | Scale abundance data
`quantile_normalise_abundance()` | Quantile normalization
`adjust_abundance()` | Adjust abundance for unwanted variation
`fill_missing_abundance()` | Fill missing abundance values
`impute_missing_abundance()` | Impute missing abundance values

### Filtering and Selection Functions
Function | Description
------------ | -------------
`identify_abundant()` | Identify abundant transcripts without removing them
`keep_abundant()` | Keep abundant transcripts
`keep_variable()` | Keep variable transcripts
`filterByExpr()` | Filter by expression

### Dimensionality Reduction Functions
Function | Description
------------ | -------------
`reduce_dimensions()` | Reduce dimensions with PCA/MDS/tSNE/UMAP
`rotate_dimensions()` | Rotate dimensions
`remove_redundancy()` | Remove redundant features

### Clustering Functions
Function | Description
------------ | -------------
`cluster_elements()` | Cluster elements with various methods
`kmeans clustering` | K-means clustering
`SNN clustering` | Shared nearest neighbor clustering
`hierarchical clustering` | Hierarchical clustering
`DBSCAN clustering` | Density-based clustering

### Differential Analysis Functions
Function | Description
------------ | -------------
`test_differential_expression()` | Test differential expression with various methods

### Cellularity Analysis Functions
Function | Description
------------ | -------------
`deconvolve_cellularity()` | Deconvolve cellularity with various methods
`cibersort()` | CIBERSORT analysis

### Gene Enrichment Functions
Function | Description
------------ | -------------
`test_gene_enrichment()` | Test gene enrichment
`test_gene_overrepresentation()` | Test gene overrepresentation
`test_gene_rank()` | Test gene rank

### Utility Functions
Function | Description
------------ | -------------
`describe_transcript()` | Describe transcript characteristics
`get_bibliography()` | Get bibliography
`resolve_complete_confounders_of_non_interest()` | Resolve confounders

### Validation and Utility Functions
Function | Description
------------ | -------------
`check_if_counts_is_na()` | Check if counts contain NA values
`check_if_duplicated_genes()` | Check for duplicated genes
`check_if_wrong_input()` | Validate input data
`log10_reverse_trans()` | Log10 reverse transformation
`logit_trans()` | Logit transformation

All functions are directly compatible with `SummarizedExperiment` objects and follow tidyverse principles for seamless integration with the tidyverse ecosystem.

### Scientific Citation

Mangiola, Stefano, Ramyar Molania, Ruining Dong, Maria A. Doyle, and Anthony T. Papenfuss. 2021. "Tidybulk: An R tidy framework for modular transcriptomic data analysis." Genome Biology 22 (42). https://doi.org/10.1186/s13059-020-02233-7

[Genome Biology - tidybulk: an R tidy framework for modular transcriptomic data analysis](https://genomebiology.biomedcentral.com/articles/10.1186/s13059-020-02233-7)

```{r setup-libraries-and-theme, echo=FALSE, include=FALSE}
library(knitr)
library(tidyverse)
library(magrittr)
library(ggplot2)
library(ggrepel)
library(tidybulk)
library(tidySummarizedExperiment)
library(SummarizedExperiment)

my_theme = 	
	theme_bw() +
	theme(
		panel.border = element_blank(),
		axis.line = element_line(),
		panel.grid.major = element_line(linewidth = 0.2),
		panel.grid.minor = element_line(linewidth = 0.1),
		text = element_text(size=12),
		legend.position="bottom",
		aspect.ratio=1,
		strip.background = element_blank(),
		axis.title.x  = element_text(margin = margin(t = 10, r = 10, b = 10, l = 10)),
		axis.title.y  = element_text(margin = margin(t = 10, r = 10, b = 10, l = 10))
	)

data(se_mini)

```

# Installation Guide

**Bioconductor**

```{r install-bioconductor, message=FALSE, eval=FALSE}
if (!requireNamespace("BiocManager")) install.packages("BiocManager")
BiocManager::install("tidybulk")
```

**Github**

```{r install-github, message=FALSE, eval=FALSE}
devtools::install_github("stemangiola/tidybulk")
```

# Comprehensive Example Pipeline

This vignette demonstrates a complete transcriptomic analysis workflow using tidybulk, with special emphasis on differential expression analysis.

## Data Overview

We will use a `SummarizedExperiment` object containing RNA-seq data:

```{r data-overview}
se_mini
```

Loading `tidySummarizedExperiment` automatically abstracts this object as a `tibble`, making it compatible with tidyverse tools while maintaining its `SummarizedExperiment` nature:

```{r check-se-class}
class(se_mini)
```

### Prepare Data for Analysis

Before analysis, we need to ensure our variables are in the correct format:

```{r convert-condition-to-factor}
# Convert condition to factor for proper differential expression analysis
colData(se_mini)$condition = as.factor(colData(se_mini)$condition)
```

### Visualize Raw Counts
Visualize the distribution of raw counts before any filtering:

```{r plot-raw-counts, fig.width = 10, fig.height = 10}
ggplot(as_tibble(se_mini), aes(counts + 1, group = .sample, color = `Cell.type`)) +
  geom_density() +
  scale_x_log10() +
  my_theme +
  labs(title = "Raw counts by cell type (before any filtering)")
```

## Step 1: Data Preprocessing

### Aggregate Duplicated Transcripts (optional)
Aggregate duplicated transcripts (e.g., isoforms, ensembl IDs):

> Transcript aggregation is a standard bioinformatics approach for gene-level summarization.

```{r preprocessing-aggregate-duplicates}
# Add gene names to rowData
rowData(se_mini)$gene_name = rownames(se_mini)

# Aggregate duplicates
se_mini = se_mini |> aggregate_duplicates(.transcript = gene_name, aggregation_function = mean)
```

### Abundance Filtering: tidybulk approaches only

Abundance filtering can be performed using tidybulk's built-in methods [@robinson2010edger; @chen2016edgeR].

#### 1. tidybulk: Default, formula_design, and CPM threshold

```{r filtering-abundance-methods}
# Default (simple filtering)
se_abundant_default = se_mini |> keep_abundant()

# With factor_of_interest (recommended for complex designs)
se_abundant_formula = se_mini |> keep_abundant(minimum_counts = 10, minimum_proportion = 0.5, factor_of_interest = condition)

# With CPM threshold (using design parameter)
se_abundant_cpm = se_mini |> keep_abundant(minimum_counts = 10, minimum_proportion = 0.5)

```

#### 2. Summary statistics and density plots

```{r filtering-summary-statistics, fig.width = 10, fig.height = 10}
# Example: summary for default tidybulk filtering
# Before filtering
se_mini |> as_tibble() |> summarise(
  n_features = n_distinct(.feature),
  min_count = min(counts),
  median_count = median(counts),
  max_count = max(counts)
)

# After filtering
se_abundant_default |> as_tibble() |> summarise(
  n_features = n_distinct(.feature),
  min_count = min(counts),
  median_count = median(counts),
  max_count = max(counts)
)

se_abundant_formula |> as_tibble() |> summarise(
  n_features = n_distinct(.feature),
  min_count = min(counts),
  median_count = median(counts),
  max_count = max(counts)
)

se_abundant_cpm |> as_tibble() |> summarise(
  n_features = n_distinct(.feature),
  min_count = min(counts),
  median_count = median(counts),
  max_count = max(counts)
)
```

```{r filtering-density-plot-comparison, fig.width = 10, fig.height = 10}
# Merge all methods into a single tibble
se_abundant_all = 
  bind_rows(
    se_mini |> assay() |> as_tibble(rownames = ".feature") |> pivot_longer(cols = -.feature, names_to = ".sample", values_to = "counts") |> mutate(method = "no filter"),
    se_abundant_default |> assay() |> as_tibble(rownames = ".feature") |> pivot_longer(cols = -.feature, names_to = ".sample", values_to = "counts") |> mutate(method = "default"),
    se_abundant_formula |> assay() |> as_tibble(rownames = ".feature") |> pivot_longer(cols = -.feature, names_to = ".sample", values_to = "counts") |> mutate(method = "formula"),
    se_abundant_cpm |> assay() |> as_tibble(rownames = ".feature") |> pivot_longer(cols = -.feature, names_to = ".sample", values_to = "counts") |> mutate(method = "cpm")
  )

# Density plot across methods
se_abundant_all |> 
  as_tibble() |> 
  ggplot(aes(counts + 1, group = .sample, color = method)) +
    geom_density() +
    scale_x_log10() +
    facet_wrap(~method) +
    my_theme +
    labs(title = "Counts after abundance filtering (tidybulk default)")
```

Update the `se_mini` object with the filtered data:

```{r update-se-mini-with-filtered}
se_mini = se_abundant_formula
```

> **Tip:** Use `formula_design` for complex designs, and use the CPM threshold for library-size-aware filtering.

### Remove Redundant Transcripts

Redundancy removal is a standard approach for reducing highly correlated features.

```{r preprocessing-remove-redundancy}
se_mini_non_redundant = 
  se_mini |> 
  remove_redundancy(method = "correlation", top = 100) 

  # Make  

se_mini |> as_tibble() |> summarise(
  n_features = n_distinct(.feature),
  min_count = min(counts),
  median_count = median(counts),
  max_count = max(counts)
)

# Summary statistics
se_mini_non_redundant |> as_tibble() |> summarise(
  n_features = n_distinct(.feature),
  min_count = min(counts),
  median_count = median(counts),
  max_count = max(counts)
)

# Plot before and after
# Merge before and after into a single tibble
se_mini_all = bind_rows(
  se_mini |> assay() |> as_tibble(rownames = ".feature") |> pivot_longer(cols = -.feature, names_to = ".sample", values_to = "counts") |>  mutate(method = "before"),
  se_mini_non_redundant |> assay() |> as_tibble(rownames = ".feature") |> pivot_longer(cols = -.feature, names_to = ".sample", values_to = "counts") |>  mutate(method = "after")
)

# Density plot
ggplot(as_tibble(se_mini_all), aes(counts + 1, group = .sample, color = method)) +
  geom_density() +
  scale_x_log10() +
  facet_wrap(~method) +
  my_theme +
  labs(title = "Counts after removing redundant transcripts")

```


### Filter Variable Transcripts
Keep only the most variable transcripts for downstream analysis.

Variance-based feature selection using edgeR methodology [@robinson2010edger] is used for selecting informative features.

```{r filtering-keep-variable}
se_mini_variable = se_mini |> keep_variable()
```

### Visualize After Variable Filtering Variable Transcripts (optional)
```{r filtering-variable-summary-and-plot, fig.width = 10, fig.height = 10}
# Before filtering
se_mini |> as_tibble() |> summarise(
  n_features = n_distinct(.feature),
  min_count = min(counts),
  median_count = median(counts),
  max_count = max(counts)
)

# After filtering
se_mini_variable |> as_tibble() |> summarise(
  n_features = n_distinct(.feature),
  min_count = min(counts),
  median_count = median(counts),
  max_count = max(counts)
)

# Density plot
# Merge before and after into a single tibble
se_mini_all = bind_rows(
  se_mini |> assay() |> as_tibble(rownames = ".feature") |> pivot_longer(cols = -.feature, names_to = ".sample", values_to = "counts") |> mutate(method = "before"),
  se_mini_variable |> assay() |> as_tibble(rownames = ".feature") |> pivot_longer(cols = -.feature, names_to = ".sample", values_to = "counts") |> mutate(method = "after")
)

# Density plot
ggplot(as_tibble(se_mini_all), aes(counts + 1, group = .sample, color = method)) +
  geom_density() +
  scale_x_log10() +
  facet_wrap(~method) +
  my_theme +
  labs(title = "Counts after variable filtering")
```


### Scale Abundance
Scale for sequencing depth using TMM [@robinson2010edger], upper quartile [@bullard2010uq], and RLE [@anders2010rle] normalization.

```{r normalization-scale-abundance}
se_mini = 
se_mini |> 
	scale_abundance(method = "TMM", suffix = "_tmm") |>
	scale_abundance(method = "upperquartile", suffix = "_upperquartile") |>
	scale_abundance(method = "RLE", suffix = "_RLE")

```

### Visualize After Scaling
```{r normalization-visualize-scaling, fig.width = 10, fig.height = 10}
# Before scaling
se_mini |> assay("counts") |> as.matrix() |> rowMeans() |> summary()

se_mini |> assay("counts_tmm") |> as.matrix() |> rowMeans() |> summary()

se_mini |> assay("counts_upperquartile") |> as.matrix() |> rowMeans() |> summary()

se_mini |> assay("counts_RLE") |> as.matrix() |> rowMeans() |> summary()

# Merge all methods into a single tibble
se_mini_scaled_all = bind_rows(
  se_mini |> assay("counts") |> as_tibble(rownames = ".feature") |> pivot_longer(cols = -.feature, names_to = ".sample", values_to = "counts") |> mutate(method = "no_scaling"),
  se_mini |> assay("counts_tmm") |> as_tibble(rownames = ".feature") |> pivot_longer(cols = -.feature, names_to = ".sample", values_to = "counts") |> mutate(method = "TMM"),
  se_mini |> assay("counts_upperquartile") |> as_tibble(rownames = ".feature") |> pivot_longer(cols = -.feature, names_to = ".sample", values_to = "counts") |> mutate(method = "upperquartile"),
  se_mini |> assay("counts_RLE") |> as_tibble(rownames = ".feature") |> pivot_longer(cols = -.feature, names_to = ".sample", values_to = "counts") |> mutate(method = "RLE")
)


# Density plot
ggplot(as_tibble(se_mini_scaled_all), aes(counts + 1, group = .sample, color = method)) +
  geom_density() +
  scale_x_log10() +
  facet_wrap(~method) +
  my_theme +
  labs(title = "Scaled counts by method (after scaling)")
```


## Step 2: Exploratory Data Analysis

### Remove Zero-Variance Features (required for PCA)

Variance filtering is a standard preprocessing step for dimensionality reduction.

```{r eda-remove-zero-variance}
library(matrixStats)
# Remove features with zero variance across samples
se_mini = se_mini[rowVars(assay(se_mini)) > 0, ]
```

### Dimensionality Reduction

MDS [@kruskal1964mds] using limma::plotMDS [@ritchie2015limma] and PCA [@hotelling1933pca] are used for dimensionality reduction.

```{r eda-mds-analysis, fig.width = 10, fig.height = 10}
se_mini = se_mini |>
  reduce_dimensions(method="MDS", .dims = 2)
```

```{r eda-pca-analysis, fig.width = 10, fig.height = 10}
se_mini = se_mini |>
  reduce_dimensions(method="PCA", .dims = 2)
```

### Visualize Dimensionality Reduction Results

```{r eda-plot-dimensionality-reduction, fig.width = 10, fig.height = 10}
# MDS plot
se_mini |>
	pivot_sample() |>
	ggplot(aes(x=`Dim1`, y=`Dim2`, color=`Cell.type`)) +
  geom_point() +
	my_theme +
	labs(title = "MDS Analysis")

# PCA plot
	se_mini |>
	pivot_sample() |>
	ggplot(aes(x=`PC1`, y=`PC2`, color=`Cell.type`)) +
	geom_point() +
	my_theme +
	labs(title = "PCA Analysis")
```

### Clustering Analysis

K-means clustering [@macqueen1967kmeans] is used for unsupervised grouping.

```{r eda-clustering-analysis, fig.width = 10, fig.height = 10}
se_mini = se_mini |>
  cluster_elements(method="kmeans", centers = 2)

# Visualize clustering
	se_mini |>
	ggplot(aes(x=`Dim1`, y=`Dim2`, color=`cluster_kmeans`)) +
  geom_point() +
  my_theme +
  labs(title = "K-means Clustering")
```

## Step 3: Differential Expression Analysis

This workflow uses 

**edgeR quasi-likelihood** [@robinson2010edger; @chen2016edgeR]
**edgeR robust likelihood ratio** [@chen2016edgeR], 
**DESeq2** [@love2014deseq2], 
**limma-voom** [@law2014voom], and 
**limma-voom with sample weights** [@liu2015voomweights] for differential expression analysis.

### Basic Differential Expression

**Methods:**

- **edgeR quasi-likelihood:** Quasi-likelihood F-tests for differential expression

- **edgeR robust likelihood ratio:** Robust likelihood ratio tests

- **DESeq2:** Negative binomial distribution with dispersion estimation

- **limma-voom:** Linear modeling with empirical Bayes moderation

- **limma-voom with sample weights:** Enhanced voom with quality weights
**References:**

- Robinson et al. (2010) edgeR: a Bioconductor package for differential expression analysis

- Chen et al. (2016) From reads to genes to pathways: differential expression analysis of RNA-Seq experiments using Rsubread and the edgeR quasi-likelihood pipeline

- Love et al. (2014) Moderated estimation of fold change and dispersion for RNA-seq data with DESeq2

- Law et al. (2014) voom: precision weights unlock linear model analysis tools for RNA-seq read counts

- Liu et al. (2015) Why weight? Modelling sample and observational level variability improves power in RNA-seq analyses

```{r differential-expression-multiple-methods}
# Standard differential expression analysis
se_mini = se_mini |>

# Use QL method
	test_differential_expression(~ condition, method = "edgeR_quasi_likelihood", prefix = "ql__") |>
	
	# Use edger_robust_likelihood_ratio
	test_differential_expression(~ condition, method = "edger_robust_likelihood_ratio", prefix = "lr_robust__") |>
	
# Use DESeq2 method
	test_differential_expression(~ condition, method = "DESeq2", prefix = "deseq2__") |>
	
	# Use limma_voom
	test_differential_expression(~ condition, method = "limma_voom", prefix = "voom__") |>

# Use limma_voom_sample_weights
	test_differential_expression(~ condition, method = "limma_voom_sample_weights", prefix = "voom_weights__") 


```

### Quality Control of the Fit

It is important to check the quality of the fit. All methods produce a fit object that can be used for quality control. The fit object produced by each underlying method are stored in as attributes of the `se_mini` object. We can use them for example to perform quality control of the fit.

#### For edgeR

Plot the biological coefficient of variation (BCV) trend. This plot is helpful to understant the dispersion of the data.

```{r differential-expression-edgeR-object}
library(edgeR)

metadata(se_mini)$tidybulk$edgeR_quasi_likelihood_object |>
  plotBCV()

```

Plot the log-fold change vs mean plot. 

```{r differential-expression-edgeR-fit}
library(edgeR)

metadata(se_mini)$tidybulk$edgeR_quasi_likelihood_fit |>
  plotMD()

```

#### For DESeq2

Plot the mean-variance trend.

```{r differential-expression-DESeq2-object}
library(DESeq2)

metadata(se_mini)$tidybulk$DESeq2_object |>
  plotDispEsts()

```

Plot the log-fold change vs mean plot.

```{r differential-expression-DESeq2-fit}
library(DESeq2)

metadata(se_mini)$tidybulk$DESeq2_object |>
  plotMA()

```










### Histograms of p-values across methods

Inspection of the raw p-value histogram provides a rapid check of differential-expression results. When no gene is truly differentially expressed, the p-values follow a uniform U(0,1) distribution across the interval 0–1, so the histogram appears flat [Source](https://bioconductor.org/help/course-materials/2014/useR2014/Workflows.html). In a more realistic scenario where only a subset of genes changes, this uniform background is still present but an obvious spike emerges close to zero, created by the genuine signals.

Thanks to the modularity of the `tidybulk` workflow, that can multiplex different methods, we can easily compare the p-values across methods.

```{r differential-expression-pvalue-histograms, fig.width = 10, fig.height = 10}
	se_mini |>
  rowData() |> 
  as_tibble() |> 
  select(
    ql__PValue, 
    lr_robust__PValue, 
    voom__P.Value, 
    voom_weights__P.Value, 
    deseq2__pvalue
  ) |> 
  pivot_longer(everything(), names_to = "method", values_to = "pvalue") |>
  ggplot(aes(x = pvalue, fill = method)) +
  geom_histogram(binwidth = 0.01) +
  facet_wrap(~method) +
  my_theme +
  labs(title = "Histogram of p-values across methods")
```



### Compare Results Across Methods

```{r differential-expression-summary-statistics}
# Summay statistics
se_mini |> rowData() |> as_tibble() |> select(contains("ql|lr_robust|voom|voom_weights|deseq2")) |> select(contains("logFC")) |> 
summarise(across(everything(), list(min = min, median = median, max = max), na.rm = TRUE))

```


### Pairplot of pvalues across methods (GGpairs)

```{r differential-expression-pvalue-pairplot, fig.width = 10, fig.height = 10, message = FALSE}

library(GGally)
se_mini |> 
  rowData() |> 
  as_tibble() |> 
  select(ql__PValue, lr_robust__PValue, voom__P.Value, voom_weights__P.Value, deseq2__pvalue) |> 
  ggpairs(columns = 1:5) +
  scale_x_continuous(trans = tidybulk::log10_reverse_trans()) +
  scale_y_continuous(trans = tidybulk::log10_reverse_trans()) +
  my_theme +
  labs(title = "Pairplot of p-values across methods")
```

### Pairplot of effect sizes across methods (GGpairs)

```{r differential-expression-effectsize-pairplot, fig.width = 10, fig.height = 10, message = FALSE}
library(GGally)
se_mini |> 
  rowData() |> 
  as_tibble() |> 
  select(ql__logFC, lr_robust__logFC, voom__logFC, voom_weights__logFC, deseq2__log2FoldChange) |> 
  ggpairs(columns = 1:5) +
  my_theme +
  labs(title = "Pairplot of effect sizes across methods")
```

### Volcano Plots for Each Method

Visualising the significance and effect size of the differential expression results as a volcano plots we appreciate that DESeq2 has much lower p-values than other methods, for the same model.

```{r differential-expression-volcano-plots-1, fig.width = 10, fig.height = 10}
# Create volcano plots
se_mini |>

	# Select the columns we want to plot
    rowData() |> 
    as_tibble(rownames = ".feature") |> 
    select(
			.feature,
      ql__logFC, ql__PValue,
      lr_robust__logFC, lr_robust__PValue,
      voom__logFC, voom__P.Value,
      voom_weights__logFC, voom_weights__P.Value,
      deseq2__log2FoldChange, deseq2__pvalue
    ) |>

	# Pivot longer to get a tidy data frame
	pivot_longer(
      - .feature,
      names_to = c("method", "stat"),
      values_to = "value", names_sep = "__"
    ) |>

	# Harmonize column names
	mutate(stat  = case_when(
		stat %in% c("logFC", "log2FoldChange") ~ "logFC",
		stat %in% c("PValue", "pvalue", "P.Value", "p.value") ~ "PValue"
	)) |>
  pivot_wider(names_from = "stat", values_from = "value") |>
  unnest( logFC, PValue) |> 

	# Plot
  ggplot(aes(x = logFC, y = PValue)) +
  geom_point(aes(color = PValue < 0.05, size = PValue < 0.05)) +
  scale_y_continuous(trans = tidybulk::log10_reverse_trans()) +
  scale_color_manual(values = c("TRUE" = "red", "FALSE" = "black")) +
  scale_size_manual(values = c("TRUE" = 0.5, "FALSE" = 0.1)) +
  facet_wrap(~method) +
  my_theme +
  labs(title = "Volcano Plots by Method")
```

Plotting independent y-axis scales for the p-values and effect sizes allows us to compare the top genes across methods.

```{r differential-expression-volcano-plots-2, fig.width = 10, fig.height = 10}
# Create volcano plots
se_mini |>

	# Select the columns we want to plot
    rowData() |> 
    as_tibble(rownames = ".feature") |> 
    select(
			.feature,
      ql__logFC, ql__PValue,
      lr_robust__logFC, lr_robust__PValue,
      voom__logFC, voom__P.Value,
      voom_weights__logFC, voom_weights__P.Value,
      deseq2__log2FoldChange, deseq2__pvalue
    ) |>

	# Pivot longer to get a tidy data frame
	pivot_longer(
      - .feature,
      names_to = c("method", "stat"),
      values_to = "value", names_sep = "__"
    ) |>

	# Harmonize column names
	mutate(stat  = case_when(
		stat %in% c("logFC", "log2FoldChange") ~ "logFC",
		stat %in% c("PValue", "pvalue", "P.Value", "p.value") ~ "PValue"
	)) |>
  pivot_wider(names_from = "stat", values_from = "value") |>
  unnest( logFC, PValue) |> 

	# Plot
  ggplot(aes(x = logFC, y = PValue)) +
  geom_point(aes(color = PValue < 0.05, size = PValue < 0.05)) +
  ggrepel::geom_text_repel(aes(label = .feature), size = 2, max.overlaps = 10) +
  scale_y_continuous(trans = tidybulk::log10_reverse_trans()) +
  scale_color_manual(values = c("TRUE" = "red", "FALSE" = "black")) +
  scale_size_manual(values = c("TRUE" = 0.5, "FALSE" = 0.1)) +
  facet_wrap(~method, scales = "free_y") +
  my_theme +
  labs(title = "Volcano Plots by Method")
```

### Differential Expression with Contrasts

Contrast-based differential expression analysis using **edgeR** [@robinson2010edger; @chen2016edgeR] is a standard statistical approach for testing specific comparisons in complex designs.

```{r differential-expression-contrasts}
# Using contrasts for more complex comparisons
se_mini |>
	test_differential_expression(
		~ 0 + condition,                  
		.contrasts = c("conditionTRUE - conditionFALSE"),
        method = "edgeR_quasi_likelihood", 
		prefix = "contrasts__"
	) |> 

	# Print the gene statistics
  pivot_transcript() |>
  select(contains("contrasts"))
```

### Differential Expression with minimum fold change (TREAT method)

TREAT method [@mccarthy2009treat] is used for testing significance relative to a fold-change threshold.

```{r differential-expression-treat-method}
# Using contrasts for more complex comparisons
se_mini |>
	test_differential_expression(
		~ 0 + condition,                  
		.contrasts = c("conditionTRUE - conditionFALSE"),
        method = "edgeR_quasi_likelihood", 
		test_above_log2_fold_change = 2, 
		prefix = "treat__"
	) |> 

	# Print the gene statistics
  pivot_transcript() |>
  select(contains("treat"))
```

### Mixed Models for Complex Designs

glmmSeq [@ma2020glmmseq] is used for generalized linear mixed models for RNA-seq data.

```{r differential-expression-mixed-models, cache=TRUE}
# Using glmmSeq for mixed models
se_mini = se_mini |>
  keep_abundant(formula_design = ~ condition) |>
  test_differential_expression(
    ~ condition + (1|Cell.type), 
    method = "glmmseq_lme4", 
    cores = 1,
	prefix = "glmmseq__"
  ) 

  se_mini |>
  pivot_transcript() 
```


### Gene Description

With tidybulk, retrieving gene descriptions is straightforward, making it easy to enhance the interpretability of your differential expression results.

```{r differential-expression-gene-description}
# Add gene descriptions using the original SummarizedExperiment
se_mini |> 

	describe_transcript() |>

	# Filter top significant genes
	filter(ql__FDR < 0.05) |>

	# Print the gene statistics
	pivot_transcript() |> 
	dplyr::select(.feature, description, contains("ql")) |> 
	head()

```

## Step 4: Batch Effect Correction

ComBat-seq [@zhang2017combatseq] is used for batch effect correction in RNA-seq data.

```{r batch-correction-adjust-abundance}
# Adjust for batch effects
se_mini = se_mini |>
  adjust_abundance(
	  .factor_unwanted = time, 
	  .factor_of_interest = condition, 
    method = "combat_seq", 
	  abundance = "counts_tmm"
  )

# Scatter plot of adjusted vs unadjusted
left_join(
    se_mini |> assay("counts_tmm") |> as_tibble(rownames = ".feature") |> pivot_longer(cols = -.feature, names_to = ".sample", values_to = "counts_tmm") ,
    se_mini |> assay("counts_tmm_adjusted") |> as_tibble(rownames = ".feature") |> pivot_longer(cols = -.feature, names_to = ".sample", values_to = "counts_tmm_adjusted") ,
	by = c(".feature", ".sample")
  ) |>
  ggplot(aes(x = counts_tmm + 1, y = counts_tmm_adjusted + 1)) +
  geom_point(aes(color = .sample), size = 0.1) +
  ggrepel::geom_text_repel(aes(label = .feature), size = 2, max.overlaps = 10) +
  scale_x_log10() +
  scale_y_log10() +
  my_theme +
  labs(title = "Scatter plot of adjusted vs unadjusted")
```



## Step 5: Cellularity Analysis

CIBERSORT [@newman2015cibersort] is used for cell type deconvolution.

Cellularity deconvolution is a standard approach for estimating the cellular composition of a sample.

### Available Deconvolution Methods

The `tidybulk` package provides several methods for deconvolution:

- **CIBERSORT** [@newman2015cibersort]: Uses support vector regression to deconvolve cell type proportions. Requires the `class`, `e1071`, and `preprocessCore` packages.
- **LLSR** [@newman2015cibersort]: Linear Least Squares Regression for deconvolution.
- **EPIC** [@racle2017epic]: Uses a reference-based approach to estimate cell fractions.
- **MCP-counter** [@becht2016mcp]: Quantifies the abundance of immune and stromal cell populations.
- **quanTIseq** [@finotello2019quantiseq]: A computational framework for inferring the immune contexture of tumors.
- **xCell** [@aran2017xcell]: Performs cell type enrichment analysis.

### Example Usage

```{r deconvolution-examples}

se_mini = 

se_mini |> 
deconvolve_cellularity(method = "cibersort", cores = 1, prefix = "cibersort__") 

```

For the rest of the methods, you need to install the `immunedeconv` package.

```{r install-immunedeconv, eval=FALSE}
if (!requireNamespace("immunedeconv")) BiocManager::install("immunedeconv")
```

```{r deconvolution-examples2, eval=FALSE}

se_mini = 

se_mini |> 
# Example using LLSR
deconvolve_cellularity(method = "llsr", cores = 1, prefix = "llsr__") |> 

# Example using EPIC
deconvolve_cellularity(method = "epic", cores = 1, prefix = "epic__") |> 

# Example using MCP-counter
deconvolve_cellularity(method = "mcp_counter", cores = 1, prefix = "mcp__") |> 

# Example using quanTIseq
deconvolve_cellularity(method = "quantiseq", cores = 1, prefix = "quantiseq__") |> 

# Example using xCell
deconvolve_cellularity(method = "xcell", cores = 1, prefix = "xcell__")
```

### Plotting Results

Visualize the cell type proportions as a stacked barplot for each method:

```{r deconvolution-plotting, fig.width = 10, fig.height = 10}
# Visualize CIBERSORT results
se_mini	 |>
  pivot_sample() |>
  select(.sample, contains("cibersort__")) |>
  pivot_longer(cols = -1, names_to = "Cell_type_inferred", values_to = "proportion") |>
  ggplot(aes(x = .sample, y = proportion, fill = Cell_type_inferred)) +
  geom_bar(stat = "identity") +
  scale_y_continuous(labels = scales::percent) +
  my_theme +
  theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5)) +
  labs(title = "CIBERSORT Cell Type Proportions")

```


```{r deconvolution-plotting2, fig.width = 10, fig.height = 10, eval=FALSE}

 # Repeat similar plotting for LLSR, EPIC, MCP-counter, quanTIseq, and xCell
se_mini	 |>
  pivot_sample() |>
  select(.sample, contains("llsr__")) |>
  pivot_longer(cols = -1, names_to = "Cell_type_inferred", values_to = "proportion") |>
  ggplot(aes(x = .sample, y = proportion, fill = Cell_type_inferred)) +
  geom_bar(stat = "identity") +
  scale_y_continuous(labels = scales::percent) +
  my_theme +
  theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5)) +
  labs(title = "LLSR Cell Type Proportions")

  se_mini	 |>
  pivot_sample() |>
  select(.sample, contains("epic__")) |>
  pivot_longer(cols = -1, names_to = "Cell_type_inferred", values_to = "proportion") |>
  ggplot(aes(x = .sample, y = proportion, fill = Cell_type_inferred)) +
  geom_bar(stat = "identity") +
  scale_y_continuous(labels = scales::percent) +
  my_theme +
  theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5)) +
  labs(title = "EPIC Cell Type Proportions")

  se_mini	 |>
  pivot_sample() |>
  select(.sample, contains("mcp__")) |>
  pivot_longer(cols = -1, names_to = "Cell_type_inferred", values_to = "proportion") |>
  ggplot(aes(x = .sample, y = proportion, fill = Cell_type_inferred)) +
  geom_bar(stat = "identity") +
  scale_y_continuous(labels = scales::percent) +
  my_theme +
  theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5)) +
  labs(title = "MCP-counter Cell Type Proportions")

  se_mini	 |>
  pivot_sample() |>
  select(.sample, contains("quantiseq__")) |>
  pivot_longer(cols = -1, names_to = "Cell_type_inferred", values_to = "proportion") |>
  ggplot(aes(x = .sample, y = proportion, fill = Cell_type_inferred)) +
  geom_bar(stat = "identity") +
  scale_y_continuous(labels = scales::percent) +
  my_theme +
  theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5)) +
  labs(title = "quanTIseq Cell Type Proportions")

  se_mini	 |>
  pivot_sample() |>
  select(.sample, contains("xcell__")) |>
  pivot_longer(cols = -1, names_to = "Cell_type_inferred", values_to = "proportion") |>
  ggplot(aes(x = .sample, y = proportion, fill = Cell_type_inferred)) +
  geom_bar(stat = "identity") +
  scale_y_continuous(labels = scales::percent) +
  my_theme +
  theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5)) +
  labs(title = "xCell Cell Type Proportions")
  
```

## Step 6: Gene Enrichment Analysis

Gene Set Enrichment Analysis (GSEA) [@subramanian2005gsea] is used for gene set enrichment.

```{r enrichment-gene-rank-analysis, eval=FALSE}
# Run gene rank enrichment (GSEA style)
gene_rank_res =
  se_mini |>

    # Filter for genes with entrez IDs
  filter(!entrez |> is.na()) |>

  # Test gene rank
  test_gene_rank(
    .entrez = entrez,
    .arrange_desc = lr_robust__logFC,
    species = "Homo sapiens",
    gene_sets = c("H", "C2", "C5")
  )
```

```{r enrichment-inspect-significant-genesets, eval=FALSE}
# Inspect significant gene sets (example for C2 collection)
gene_rank_res |>
  filter(gs_collection == "C2") |>
  dplyr::select(-fit) |>
  unnest(test) |>
  filter(p.adjust < 0.05)
```

#### Visualize enrichment 
```{r enrichment-visualize-gsea-plots, eval=FALSE}
  library(enrichplot)
  library(patchwork)
  gene_rank_res |>
    unnest(test) |>
    head() |>
    mutate(plot = pmap(
      list(fit, ID, idx_for_plotting, p.adjust),
      ~ enrichplot::gseaplot2(
        ..1, geneSetID = ..3,
        title = sprintf("%s \nadj pvalue %s", ..2, round(..4, 2)),
        base_size = 6, rel_heights = c(1.5, 0.5), subplots = c(1, 2)
      )
    )) |>
    pull(plot) 

```

Gene Ontology overrepresentation analysis [@ashburner2000go] is used for functional enrichment. 

```{r enrichment-gene-overrepresentation, eval=FALSE}
# Test gene overrepresentation
se_mini_overrep = 
  se_mini |>
  
  # Label genes to test overrepresentation of
  mutate(genes_to_test = ql__FDR < 0.05) |>
  
    # Filter for genes with entrez IDs
  filter(!entrez |> is.na()) |>
  
  test_gene_overrepresentation(
    .entrez = entrez,
    species = "Homo sapiens",
    .do_test = genes_to_test,
    gene_sets = c("H", "C2", "C5")
  )

  se_mini_overrep
```

EGSEA [@alhamdoosh2017egsea] is used for ensemble gene set enrichment analysis. EGSEA is a method that combines multiple gene set enrichment analysis methods to provide a more robust and comprehensive analysis of gene set enrichment. It creates a web-based interactive tool that allows you to explore the results of the gene set enrichment analysis.

```{r enrichment-egsea-analysis, eval=FALSE}
library(EGSEA)
# Test gene enrichment
  se_mini |> 

  # Filter for genes with entrez IDs
  filter(!entrez |> is.na()) |>

  # Test gene enrichment
  test_gene_enrichment(
    .formula = ~condition,
    .entrez = entrez,
    species = "human", 
    gene_sets = "h",
    methods = c("roast"),  # Use a more robust method
    cores = 1
  )

```


## Bibliography

`tidybulk` allows you to get the bibliography of all methods used in our workflow.

```{r bibliography-get-methods}
# Get bibliography of all methods used in our workflow
se_mini |> get_bibliography()
```


```{r session-info}
sessionInfo()
```